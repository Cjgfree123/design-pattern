## 设计模式

### 目录

```
demo
    |__factory工厂
        |__simple.js 简单工厂模式
        |__factory.js 工厂方法模式
        |__abstract.js 抽象工厂模式
```

### 概念

- 把客观对象抽象成属性数据和对数据的相关操作，把内部细节和不相关的信息隐藏起来。
- 把同一个类型的客观对象属性数据和操作绑定在一起，封装成类。
- 允许分成不同层次进行抽象，通过继承实现属性和操作的共享
    - 面向对象的分析 OOA
    - 面向对象的设计 OOD
    - 面向对象的编程 OOP
- 写法
    1. 类
    2. public,protected, private
    3. 多态，继承等
    4. 命名空间

### 原则 

> 设计原则SOLID

**Single[单一职责]。**

    例如: 

    dva中request函数:

    (1)处理状态码

    (2)将响应体转成JSON

    (3)单独封装fetch请求。

**Open[开放封闭原则]:**

    对扩展开放，对修改关闭
    增加需求时，扩展新代码，而非修改已有代码

    里氏替换原则:
    (1)子类能覆盖父类
    (2)父类能出现的地方，子类就能出现。

    接口隔离原则


### demo

##### 工厂模式

1. simple.js 简单工厂模式 

(简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。)

2. factory.js 工厂方法模式 

(将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类;    
 将工厂方法看作是一个实例化对象的工厂类;  
 可以使用new.target来模拟出抽象类。new.target指向直接被new执行的构造函数，我们对new.target进行判断，如果指向了该类则抛出错误来使得该类成为抽象类。)

3. abstract.js 抽象工厂模式

简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。

**实战**

使用addRoutes + role实现权限路由。

点评: 在实际项目中，因为使用this.$router.addRoutes方法添加的路由刷新后不能保存，所以会导致路由无法访问。通常的做法是本地加密保存用户信息，在刷新后获取本地权限并解密，根据权限重新添加路由。这里因为和工厂模式没有太大的关系就不再赘述。

**使用场景**

将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；

比如: jq的$、 React的createElement()、Vue的异步组件。

**优点**

外部不许关心内部构造器是怎么生成的，只需调用一个工厂方法生成一个实例即可；

构造函数和创建者分离，符合开放封闭原则

